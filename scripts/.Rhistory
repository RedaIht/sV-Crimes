out <- split(bP.data, cut(bP.data$age, c(20,25,30,35,40,45,50,55,60), include.lowest = T));
X <- cbind(1, c(out[1]))
bP.model[['coefficients']]
mlEstimator2 <- function(X, Y, bHat) {
sigma.hat.q   <- 1/dim(X)[1] * t(Y - X%*%bHat) %*% (Y - X%*%bHat)
sigma.tilde.q <- 1 / (dim(X)[1] - (dim(X)[2]+1)) * sigma.hat.q
return(c(sigma.hat.q[1], sigma.tilde.q[1]))
}
vars.tilde <- rep(0, length(out))
i <- 0
for (n in names(out)) {
i <- i +1
R <- mlEstimator2(cbind(1, out[[n]]$age), out[[n]]$bp, bP.model$coefficients)
vars.tilde[i] = R[2]
return(vars.tilde)
}
for (n in names(out)) {
i <- i +1
R <- mlEstimator2(cbind(1, out[[n]]$age), out[[n]]$bp, bP.model$coefficients)
vars.tilde[i] = R[2]
return(vars.tilde)
}
bP.model <- lm(bp~age, data = bP.data)
bP.pred <- predict(bP.model)
bP.pred
out <- split(bP.data, cut(bP.data$age, c(20,25,30,35,40,45,50,55,60), include.lowest = T));
X <- cbind(1, c(out[1]))
bP.model[['coefficients']]
mlEstimator2 <- function(X, Y, bHat) {
sigma.hat.q   <- 1/dim(X)[1] * t(Y - X%*%bHat) %*% (Y - X%*%bHat)
sigma.tilde.q <- 1 / (dim(X)[1] - (dim(X)[2]+1)) * sigma.hat.q
return(c(sigma.hat.q[1], sigma.tilde.q[1]))
}
vars.tilde <- rep(0, length(out))
i <- 0
for (n in names(out)) {
i <- i +1
R <- mlEstimator2(cbind(1, out[[n]]$age), out[[n]]$bp, bP.model$coefficients)
vars.tilde[i] = R[2]
}
vars.tilde
bP.model <- lm(bp~age, data = bP.data)
bP.pred <- predict(bP.model)
bP.pred
out <- split(bP.data, cut(bP.data$age, c(20,25,30,35,40,45,50,55,60), include.lowest = T));
X <- cbind(1, c(out[1]))
bP.model[['coefficients']]
mlEstimator2 <- function(X, Y, bHat) {
sigma.hat.q   <- 1/dim(X)[1] * t(Y - X%*%bHat) %*% (Y - X%*%bHat)
sigma.tilde.q <- 1 / (dim(X)[1] - (dim(X)[2]+1)) * sigma.hat.q
return(c(sigma.hat.q[1], sigma.tilde.q[1]))
}
vars.tilde <- rep(0, length(out))
i <- 0
for (n in names(out)) {
i <- i +1
R <- mlEstimator2(cbind(1, out[[n]]$age), out[[n]]$bp, bP.model$coefficients)
vars.tilde[i] = R[2]
}
vars.tilde
x <- 1/miete.data$flaeche
y <- miete.data$mieteqm
z <- miete.data$bjahr^2
simple.model <- lm(y~x)
simple.pred <- predict(simple.model)
simple.model <- lm(y~x)
# anwendung von predict
simple.pred <- predict(simple.model)
## a)
simple.beta0.hat <- simple.model$coefficients[[1]]
simple.beta1.hat <- simple.model$coefficients[[2]]
simple.beta0.hat
simple.beta1.hat
head(simple.m)
head(years.m)
source('~/Dokumente/Master/3. Fachsemester/statistische Verfahren/WS 17⁄18/Übungen/vS/Übung 4/uebung4.R', echo=TRUE)
bP.model <- lm(bp~age, data = bP.data)
bP.pred <- predict(bP.model)
bP.pred
# anlegen der altersintervalle
out <- split(bP.data, cut(bP.data$age, c(20,25,30,35,40,45,50,55,60), include.lowest = T));
X <- cbind(1, c(out[1]))
bP.model[['coefficients']]
# anpassung der funktion von oben
mlEstimator2 <- function(X, Y, bHat) {
sigma.hat.q   <- 1/dim(X)[1] * t(Y - X%*%bHat) %*% (Y - X%*%bHat)
sigma.tilde.q <- 1 / (dim(X)[1] - (dim(X)[2]+1)) * sigma.hat.q
return(c(sigma.hat.q[1], sigma.tilde.q[1]))
}
vars.tilde <- rep(0, length(out))
i <- 0
for (n in names(out)) {
i <- i +1
R <- mlEstimator2(cbind(1, out[[n]]$age), out[[n]]$bp, bP.model$coefficients)
vars.tilde[i] = R[2]
}
vars.tilde
sC.matrix <- matrix(unlist(sC), ncol = 16, byrow = FALSE)
### Pseudos ###
require(MASS)
# models from winners.R
pseudo.data1 <- rnegbin(90, mu = predict(m1, type = "response"),
theta = 0.7566)
pseudo.data2 <- rpois(90, lambda = predict(m1, type = "response"))
head(pseudo.data1)
pseudo.data2
plot(pseudo.data2)
plot(crimes~(1+density), data = crimes.data, col = region, pch = 16)
points(crimes.data$crimes, pseudo.data, col = 9)
points(crimes.data$crimes)
points(pseudo.data2, col = 3)
## gegenüberstellung:
# daten ohne ausreißer
plot(crimes.data.noWest$crimes)
# inkl pseudos
points(pseudo.data1, col = "green")
# daten mit ausreißern
plot(crimes.data$crimes, col = "blue")
points(pseudo.data1, col = "red")
### wähle randomisiert 30 elemente aus crimes.data$crimes aus
### und vergleiche diese mit 30 randomisierten zufallszahlen von rpois(), wenn theta = -1
### oder rnegbin(), wenn theta >= 0
test <- function(seed = 1234, amount = 30, model = mStepO, theta = -1) {
set.seed(seed)
# decide whether to use rnegbin or rpois distribution for computing pseudo-values (sP)
# and get random values from crimes.data$crimes
if(theta == -1) {
sP <- rpois(amount, lambda = predict(model, type = "response"))
} else {
sP <- rnegbin(amount, mu = predict(model, type = "response"),
theta = theta)
}
sP <- sP[!is.na(sP)]
#sC <- sample(crimes.data$crimes, length(sP))
sC <- crimes.data[sample(1:90, amount), ]
# plot real data from crimes.data$crimes in black and pseudos in blue
# and draw linear function per coefficients
plot(sC$crimes)
points(sP, col = "blue")
i <- 3
for(c in m3O2$coefficients[2:length(m3O2$coefficients)]) {
abline(model$coefficients[[1]], c, col = i)
i <- i+1
}
# print median distance values between the real and the estimated value
dist <- sC-sP
dist
print(abs(median(dist)))
### ???? brauch ich das wirklich?, das geht doch nur für modelle mit einem eingabevektor
tm <- cbind(rep(1,amount), sP)
am <- cbind(rep(1,amount), sC)
c  <- cov(tm, am)
c <- cov(sP, sC)
print(c)
# print correlation coefficient
print(cor(tm, am))
# compute covariance matrix
#acm <- vcov(model)
mv <- c()
sC.matrix <- matrix(unlist(sC), ncol = 16, byrow = FALSE)
for(col in sC) {
append(mv, mean(col))
sC_mean <- matrix(data=1, nrow=n) %*% cbind(mean(a),mean(b),mean(c),mean(d),mean(e))
}
x <- cbind(1, crimes.data$crimes)
head(x)
beta.hat <- solve(t(x) %*% x) %*% t(x) %*% crimes.data$crimes
beta.hat
x <- crimes.data$density
y <- crimes.data$crimes
plot(x,y)
abline(beta.hat, col = 2, lwd = 3)
abline(c(mDensity$coefficients[1], mDensity$coefficients[2]), col = 3, lwd = 3)
## deviance:
# zitat faustregel:
# ein modell M ist ein geeignetes modell, falls die Devienz von M so groß ist, wie die ugf
# anzahl der parameter von M
dt <- function(model) {
deviance(model) - abs(model$rank)
}
dt(m1); dt(m2); dt(m3); dt(m4); dt(m5)
test(seed = 6153134) #-431
test(seed = 2165464, model = m2) #460 ## m2 aus winners.R!
test(seed = 6548, model = m2) #566.5
test(seed = 6548, model = m1) #648.5
test(seed = 6546512, model = m2) #-94.5
test(seed = 6546512, model = m1) #207
test(seed = 6546512, model = m2, theta = -1) #-94.5
test(seed = 6546512, model = m1, theta = 0.6289) #742
# 742
test(seed = 6546512, model = m2, theta = 0.6289)
mDensity <- glm.nb(crimes~density, data = crimes.data)
test(seed = 6546512, model = mDensity, theta = 0.54)
test(seed = 6546512, model = mDensity, theta = -1)
test(model = mDensity)
deviance(m3O2)
deviance(mDensity)
test(seed = 74158352, model = m2, theta = 3.416778004)
# immer das theta aus dem modell nehmen!
# gibt gute werte.
1+1
c <- crimes.data[sample(1:90, amount),]
crimes.data <- read.csv("crimes.csv")
setwd("~/Dokumente/Master/3. Fachsemester/statistische Verfahren/WS 17⁄18/projekt/crimes/scripts")
c <- crimes.data[sample(1:90, amount),]
setwd("~/Dokumente/Master/3. Fachsemester/statistische Verfahren/WS 17⁄18/projekt/crimes/scripts")
crimes.data <- read.csv("crimes.csv")
c <- crimes.data[sample(1:90, amount),]
amount <- 30
c <- crimes.data[sample(1:90, amount),]
c
c.m <- cbind(c[,1], c[,5])
c.cov <- cov(c.m)
c.cov
b
mDen
mDens### Pseudos ###
require(MASS)
library(nlmeODE)
require(nlmeODE)
# models from winners.R
pseudo.data1 <- rnegbin(90, mu = predict(m1, type = "response"),
theta = 0.7566)
pseudo.data2 <- rpois(90, lambda = predict(m1, type = "response"))
head(pseudo.data1)
pseudo.data2
plot(pseudo.data2)
plot(crimes~(1+density), data = crimes.data, col = region, pch = 16)
points(crimes.data$crimes, pseudo.data, col = 9)
points(crimes.data$crimes)
points(pseudo.data2, col = 3)
## gegenüberstellung:
# daten ohne ausreißer
plot(crimes.data.noWest$crimes)
# inkl pseudos
points(pseudo.data1, col = "green")
# daten mit ausreißern
plot(crimes.data$crimes, col = "blue")
points(pseudo.data1, col = "red")
### wähle randomisiert 30 elemente aus crimes.data$crimes aus
### und vergleiche diese mit 30 randomisierten zufallszahlen von rpois(), wenn theta = -1
### oder rnegbin(), wenn theta >= 0
test <- function(seed = 1234, amount = 30, model = m1, theta = -1) {
set.seed(seed)
# decide whether to use rnegbin or rpois distribution for computing pseudo-values (sP)
# and get random values from crimes.data$crimes
if(theta == -1) {
sP <- rpois(amount, lambda = predict(model, type = "response"))
} else {
sP <- rnegbin(amount, mu = predict(model, type = "response"),
theta = 2.103304731)
}
sP <- sP[!is.na(sP)]
#sC <- sample(crimes.data$crimes, length(sP))
sC <- crimes.data[sample(1:90, amount), ]
# plot real data from crimes.data$crimes in black and pseudos in blue
# and draw linear function per coefficients
plot(sC$crimes)
points(sP, col = "blue")
i <- 3
for(c in model$coefficients[2:length(model$coefficients)]) {
abline(model$coefficients[[1]], c, col = i)
i <- i+1
}
# print median distance values between the real and the estimated value
dist <- sC-sP
dist
print(abs(median(dist)))
# print correlation coefficient
print(cor(tm, am))
# compute covariance matrix
sC.matrix <- matrix(unlist(sC), ncol = 16, byrow = FALSE) # sC as a matrix
sC.tcov <- cov(sC.matrix)
sC.acov <- vcov(mDensity)
}
x <- cbind(1, crimes.data$crimes)
head(x)
beta.hat <- solve(t(x) %*% x) %*% t(x) %*% crimes.data$crimes
beta.hat
plot(crimes.data$crimes)
abline(beta.hat)
x <- crimes.data$density
y <- crimes.data$crimes
plot(x,y)
abline(beta.hat, col = 2, lwd = 3)
abline(c(mDensity$coefficients[1], mDensity$coefficients[2]), col = 3, lwd = 3)
## deviance:
# zitat faustregel:
# ein modell M ist ein geeignetes modell, falls die Devienz von M so groß ist, wie die ugf
# anzahl der parameter von M
dt <- function(model) {
deviance(model) - abs(model$rank)
}
dt(m1); dt(m2); dt(m3); dt(m4); dt(m5)
test(seed = 6153134) #-431
test(seed = 2165464, model = m2) #460 ## m2 aus winners.R!
test(seed = 6548, model = m2) #566.5
test(seed = 6548, model = m1) #648.5
test(seed = 6546512, model = m2) #-94.5
test(seed = 6546512, model = m1) #207
test(seed = 6546512, model = m2, theta = -1) #-94.5
test(seed = 6546512, model = m1, theta = 0.6289) #742
# 742
test(seed = 6546512, model = m2, theta = 0.6289)
mDensity <- glm.nb(crimes~density, data = crimes.data)
test(seed = 6546512, model = mDensity, theta = 0.54)
test(seed = 6546512, model = mDensity, theta = -1)
test(model = mDensity)
deviance(m3O2)
deviance(mDensity)
test(seed = 74158352, model = m2, theta = 3.416778004)
# immer das theta aus dem modell nehmen!
# gibt gute werte.
mDensity <- glm.nb(crimes~density, data = crimes.data)
simulation <- function(seed = 1234, model = mDensity, amount = 30, theta = -1) {
set.seed(seed)
#c <- cbind(1, crimes.data[sample(1:90, amount), ]$density)
c <- crimes.data[sample(1:90, amount),]
m <- glm.nb(crimes~density, data = c)
p <- rnegbin(amount, mu = predict(m, type = "response"),
theta = 1.770278793)
plot(c$crimes)
points(p, col = 2)
c.m <- cbind(c[,1], c[,5])
c.cov <- cov(c.m)
#c.cov <- (nrow(c.m)-1)^-1 * solve(t(c.m)%*% c.m)
p.m <- cbind(c(p), c[,5])
#p.cov <- (nrow(p.m)-1)^-1 * solve(t(p.m)%*% p.m)
p.cov <- cov
}
mDensity
m <- glm.nb(crimes~density, data = c)
maxAmount <- 30
amount <- sample(1:maxAmount, 1)
amount
repeats <- 20
c <- crimes.data[sample(1:maxAmount),]
c <- crimes.data[sample(1:amount), ]
dm <- model.matrix(c)
c
dm <- model.matrix(c$crimes)
dm <- model.matrix(cbind(c$crimes, c$density))
attributes(c)
c$crimes
cbind(c$crimes, c$density)
dm <- cbind(c$crimes, c$density)
dm
m <- glm.nb(crimes~density, data = dm)
c.dm <- data.frame(cbind(c$crimes, c$density))
c.dm
?data.frame
colnames(c.dm) <- c("crimes", "density")
c.dm
m <- glm.nb(crimes~density, data = c.dm)
m
betas <- c()
betas
betas <- matrix(ncol = 2, dimnames = c("beta0.hat", "beta1.hat"))
betas <- matrix(ncol = 2); dimnames(betas) <- c("beta0.hat", "beta1.hat")
betas <- matrix(ncol = 2); colnames(betas) <- c("beta0.hat", "beta1.hat")
betas
for(i in 1:repeats) {
amount <- sample(1:maxAmount, 1)
m <- glm.nb(crimes~density, data = c.dm)
rbind(betas, m$coefficients)
p <- rnegbin(amount, mu = predict(m, type = "response"),
theta = 1.770278793)
}
betas
p
length(p)
m <- glm.nb(crimes~density, data = c.dm)
rbind(betas, m$coefficients)
betas <- betas[!is.na(betas)]
betas
betas <- matrix(ncol = 2, nrow = repeats); colnames(betas) <- c("beta0.hat", "beta1.hat")
betas
for(i in 1:repeats) {
amount <- sample(1:maxAmount, 1)
m <- glm.nb(crimes~density, data = c.dm)
betas[i,] <- m$coefficients
p <- rnegbin(amount, mu = predict(m, type = "response"),
theta = 1.770278793)
}
betas
for(i in 1:repeats) {
# baue design-matrix
c.dm <- data.frame(cbind(c$crimes, c$density))
colnames(c.dm) <- c("crimes", "density")
amount <- sample(1:maxAmount, 1)
m <- glm.nb(crimes~density, data = c.dm)
betas[i,] <- m$coefficients
p <- rnegbin(amount, mu = predict(m, type = "response"),
theta = 1.770278793)
}
betas
for(i in 1:repeats) {
# wähle stichprobenumfang
c <- crimes.data[sample(1:amount), ]
# baue design-matrix
c.dm <- data.frame(cbind(c$crimes, c$density))
colnames(c.dm) <- c("crimes", "density")
amount <- sample(1:maxAmount, 1)
m <- glm.nb(crimes~density, data = c.dm)
betas[i,] <- m$coefficients
p <- rnegbin(amount, mu = predict(m, type = "response"),
theta = 1.770278793)
}
c <- crimes.data[sample(1:amount), ]
c.dm <- data.frame(cbind(c$crimes, c$density))
colnames(c.dm) <- c("crimes", "density")
amount <- sample(1:maxAmount, 1)
m <- glm.nb(crimes~density, data = c.dm)
betas[i,] <- m$coefficients
betas
length(c.dm)
dim(c.dm)
sample(1:dim(c.dm)[1],sample(1:dim(c.dm)[1]))
sample(1:dim(c.dm)[1],sample(1:dim(c.dm)[1]))
c.tdm <- c.dm[sample(1:dim(c.dm)[1],sample(1:dim(c.dm)[1]))] # test design-matrix
c.tdm <- c.dm[sample(1:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
c.tdm
for(i in 1:repeats) {
c.tdm <- c.dm[sample(1:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.dm)
betas[i,] <- m$coefficients
p <- rnegbin(amount, mu = predict(m, type = "response"),
theta = 1.770278793)
}
betas
for(i in 1:repeats) {
c.tdm <- c.dm[sample(1:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
#p <- rnegbin(amount, mu = predict(m, type = "response"),
#             theta = 1.770278793)
}
c.tdm <- c.dm[sample(1:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
c.tdm
glm.nb(crimes~density, data = c.tdm
)
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
m
for(i in 1:repeats) {
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
#p <- rnegbin(amount, mu = predict(m, type = "response"),
#             theta = 1.770278793)
}
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
betas
m$call
for(i in 1:repeats) {
c.tdm <- c.dm[sample(5:dim(c.dm)[1],sample(1:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
p <- rnegbin(amount, mu = predict(m, type = "response"), theta = m$call$init.theta)
}
for(i in 1:repeats) {
c.tdm <- c.dm[sample(1:dim(c.dm)[1],sample(5:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
p <- rnegbin(amount, mu = predict(m, type = "response"), theta = m$call$init.theta)
}
betas
var(betas)
cov(betas)
simulation <- function(model = mDensity, maxAmount = 30, repeats = 20) {
# wähle stichprobenumfang
c <- crimes.data[sample(1:amount), ]
# baue design-matrix
c.dm <- data.frame(cbind(c$crimes, c$density))
colnames(c.dm) <- c("crimes", "density")
# simuliere mehrfache pseudobeobachtungen
betas <- matrix(ncol = 2, nrow = repeats); colnames(betas) <- c("beta0.hat", "beta1.hat")
for(i in 1:repeats) {
c.tdm <- c.dm[sample(1:dim(c.dm)[1],sample(5:dim(c.dm)[1])), ] # test design-matrix
m <- glm.nb(crimes~density, data = c.tdm)
betas[i,] <- m$coefficients
p <- rnegbin(amount, mu = predict(m, type = "response"), theta = m$call$init.theta)
}
var(betas)
cov(betas)
}
(betas)
(betas)
install.packages("locfit")
require(locfit)
?cp
